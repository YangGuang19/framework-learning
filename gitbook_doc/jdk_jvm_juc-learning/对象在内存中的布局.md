<!-- TOC -->

   * [对象在内存中的布局(64位)](#对象在内存中的布局64位)
        * [对象头](#对象头)
        * [实例数据](#实例数据)
        * [对齐填充](#对齐填充)
 
<!-- /TOC -->

# 对象在内存中的布局(64位)

PS:对象在内存中的布局,在32位和64位上的实现也是不同的，以我的
机器为例(64位)

**对象在内存中由 对象头,实例数据,对齐填充三部分组成。**

![对象内存布局](../../img/jdk_jvm_juc/对象在内存中的布局.png)
    
#### 对象头
>对象头可以分为2部分数据组成,**如果是数组,对象头还会保存数组长度。**

可以看到在hotspot虚拟机中的对象头由2部分组成:
mark 和 metadata(klass* , compressed_klass)(见oop.hpp文件):

![对象头组成1](../../img/jdk_jvm_juc/对象头的markword组成1.png)

下面是mark/markword的组成(见:markOop.hpp头文件):

![对象头组成2](../../img/jdk_jvm_juc/对象头的markword组成2.png)

对象处于每种状态时的锁标志位都不同(见:markOop.hpp头文件):

![对象头组成3](../../img/jdk_jvm_juc/对象头的markword组成3.png)

![对象头组成4](../../img/jdk_jvm_juc/对象头的markword组成4.png)

- Mark Word(mark)

   | 锁状态   | 锁标志  |   markword组成      |
   | :---:   | :---:  |     :---:    |
   |无锁     |  01    |  由hashcode,分代年龄,偏向锁,锁标志位组成 |
   |偏向锁   |  01    |  由偏向线程的ID,偏向时间戳(epoch),偏向锁,分代年龄,锁标志位组成|
   |轻量级锁 |  00    |  由指向栈中锁的记录和锁标志位组成 |
   |膨胀锁  |  10    |   由指向锁的指针和锁标志位组成   |
   | GC    |  11    |   无数据  |                               
           
- Klass Pointer /  Compressed Klass: **Klass Pointer是指向对象类型的指针，指针指向对象的类元数据。**
jvm通过klass pointer判断对象属于哪个类。
在64位的jvm实现中，Klass Pointer的长度为64bit(32位系统,
指针为32bit)，也就意味着,64位系统比32位的系统占用更多内存。
**jvm提供了压缩指针(Compressed Klass)，可以使用-XX:+UseCompressedOops
来开启指针压缩。**
           
#### 实例数据
>实例数据存储着对象在程序中被定义的各个字段的数据,也就是对象的字段的
>数据。
        
#### 对齐填充
>**Java对象的小必须是8字节的倍数**,像13,15这种非8的倍数的对象的大小,
>不足或多余的部分就要使用对齐填充数据补齐。
>如果Java对象大小正好是8的倍数,那么就无需对齐填充数据。

**PS:可以使用openjdk-jol工具查看对象大小**